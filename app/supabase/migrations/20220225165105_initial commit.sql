-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE TABLE IF NOT EXISTS public.challenge_pools
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    description text COLLATE pg_catalog."default" NOT NULL,
    owner uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT challenge_pools_pkey PRIMARY KEY (id),
    CONSTRAINT challenge_pools_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.challenge_pools
    OWNER to postgres;

ALTER TABLE IF EXISTS public.challenge_pools
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.challenge_pools TO anon;

GRANT ALL ON TABLE public.challenge_pools TO authenticated;

GRANT ALL ON TABLE public.challenge_pools TO postgres;

GRANT ALL ON TABLE public.challenge_pools TO service_role;

CREATE TABLE IF NOT EXISTS public.open_questions
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    question_text text COLLATE pg_catalog."default" NOT NULL,
    challenge_pool uuid NOT NULL,
    owner uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT open_questions_pkey PRIMARY KEY (id),
    CONSTRAINT open_questions_challenge_pool_fkey FOREIGN KEY (challenge_pool)
        REFERENCES public.challenge_pools (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT open_questions_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.open_questions
    OWNER to postgres;

ALTER TABLE IF EXISTS public.open_questions
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.open_questions TO anon;

GRANT ALL ON TABLE public.open_questions TO authenticated;

GRANT ALL ON TABLE public.open_questions TO postgres;

GRANT ALL ON TABLE public.open_questions TO service_role;
CREATE POLICY oq_insert_policy_for_authenticated_user
    ON public.open_questions
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY oq_select_policy_for_authenticated_user
    ON public.open_questions
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));

CREATE TABLE IF NOT EXISTS public.correct_open_answers
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    answer_text text COLLATE pg_catalog."default" NOT NULL,
    open_question uuid NOT NULL,
    owner uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT correct_open_answers_pkey PRIMARY KEY (id),
    CONSTRAINT correct_open_answers_open_question_fkey FOREIGN KEY (open_question)
        REFERENCES public.open_questions (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT correct_open_answers_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.correct_open_answers
    OWNER to postgres;

ALTER TABLE IF EXISTS public.correct_open_answers
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.correct_open_answers TO anon;

GRANT ALL ON TABLE public.correct_open_answers TO authenticated;

GRANT ALL ON TABLE public.correct_open_answers TO postgres;

GRANT ALL ON TABLE public.correct_open_answers TO service_role;
CREATE POLICY coa_insert_policy_for_authenticated_user
    ON public.correct_open_answers
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY coa_select_policy_for_owner
    ON public.correct_open_answers
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = owner));

CREATE TABLE IF NOT EXISTS public.open_answer_drafts
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    answer_text text COLLATE pg_catalog."default" NOT NULL,
    open_question uuid NOT NULL,
    owner uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT open_answer_drafts_pkey PRIMARY KEY (id),
    CONSTRAINT open_answer_drafts_open_question_fkey FOREIGN KEY (open_question)
        REFERENCES public.open_questions (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT open_answer_drafts_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.open_answer_drafts
    OWNER to postgres;

ALTER TABLE IF EXISTS public.open_answer_drafts
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.open_answer_drafts TO anon;

GRANT ALL ON TABLE public.open_answer_drafts TO authenticated;

GRANT ALL ON TABLE public.open_answer_drafts TO postgres;

GRANT ALL ON TABLE public.open_answer_drafts TO service_role;
CREATE POLICY oad_delete_policy_for_owner
    ON public.open_answer_drafts
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = owner));
CREATE POLICY oad_insert_policy_for_authenticated_user
    ON public.open_answer_drafts
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY oad_select_policy_for_owner
    ON public.open_answer_drafts
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = owner));

CREATE TABLE IF NOT EXISTS public.invite_codes
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    code text COLLATE pg_catalog."default" NOT NULL,
    challenge_pool uuid NOT NULL,
    owner uuid NOT NULL,
    valid_until timestamp without time zone NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT invite_codes_pkey PRIMARY KEY (id),
    CONSTRAINT invite_codes_challenge_pool_fkey FOREIGN KEY (challenge_pool)
        REFERENCES public.challenge_pools (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT invite_codes_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.invite_codes
    OWNER to postgres;

ALTER TABLE IF EXISTS public.invite_codes
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.invite_codes TO anon;

GRANT ALL ON TABLE public.invite_codes TO authenticated;

GRANT ALL ON TABLE public.invite_codes TO postgres;

GRANT ALL ON TABLE public.invite_codes TO service_role;
CREATE POLICY ic_insert_policy_for_authenticated_user
    ON public.invite_codes
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY ic_select_policy_for_owner
    ON public.invite_codes
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = owner));

CREATE TABLE IF NOT EXISTS public.open_answers
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    answer_text text COLLATE pg_catalog."default" NOT NULL,
    version bigint NOT NULL,
    open_question uuid NOT NULL,
    owner uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT open_answers_pkey PRIMARY KEY (id),
    CONSTRAINT open_answers_open_question_fkey FOREIGN KEY (open_question)
        REFERENCES public.open_questions (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT open_answers_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.open_answers
    OWNER to postgres;

ALTER TABLE IF EXISTS public.open_answers
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.open_answers TO anon;

GRANT ALL ON TABLE public.open_answers TO authenticated;

GRANT ALL ON TABLE public.open_answers TO postgres;

GRANT ALL ON TABLE public.open_answers TO service_role;
CREATE POLICY oa_insert_policy_for_authenticated_user
    ON public.open_answers
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY oa_select_policy_for_authenticated_user
    ON public.open_answers
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));

CREATE TABLE IF NOT EXISTS public.open_feedback_drafts
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    feedback_text text COLLATE pg_catalog."default" NOT NULL,
    open_answer uuid NOT NULL,
    owner uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT open_feedback_drafts_pkey PRIMARY KEY (id),
    CONSTRAINT open_feedback_drafts_open_answer_fkey FOREIGN KEY (open_answer)
        REFERENCES public.open_answers (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT open_feedback_drafts_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.open_feedback_drafts
    OWNER to postgres;

ALTER TABLE IF EXISTS public.open_feedback_drafts
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.open_feedback_drafts TO anon;

GRANT ALL ON TABLE public.open_feedback_drafts TO authenticated;

GRANT ALL ON TABLE public.open_feedback_drafts TO postgres;

GRANT ALL ON TABLE public.open_feedback_drafts TO service_role;
CREATE POLICY ofd_delete_policy_for_owner
    ON public.open_feedback_drafts
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = owner));
CREATE POLICY ofd_insert_policy_for_authenticated_user
    ON public.open_feedback_drafts
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY ofd_select_policy_for_owner
    ON public.open_feedback_drafts
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = owner));

CREATE TABLE IF NOT EXISTS public.open_question_drafts
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    question_text text COLLATE pg_catalog."default" NOT NULL,
    answer_text text COLLATE pg_catalog."default",
    challenge_pool uuid NOT NULL,
    owner uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT open_question_drafts_pkey PRIMARY KEY (id),
    CONSTRAINT open_question_drafts_challenge_pool_fkey FOREIGN KEY (challenge_pool)
        REFERENCES public.challenge_pools (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT open_question_drafts_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.open_question_drafts
    OWNER to postgres;

ALTER TABLE IF EXISTS public.open_question_drafts
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.open_question_drafts TO anon;

GRANT ALL ON TABLE public.open_question_drafts TO authenticated;

GRANT ALL ON TABLE public.open_question_drafts TO postgres;

GRANT ALL ON TABLE public.open_question_drafts TO service_role;
CREATE POLICY oqd_delete_policy_for_owner
    ON public.open_question_drafts
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = owner));
CREATE POLICY oqd_insert_policy_for_authenticated_user
    ON public.open_question_drafts
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY oqd_select_policy_for_owner
    ON public.open_question_drafts
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = owner));
CREATE POLICY oqd_update_policy_for_owner
    ON public.open_question_drafts
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = owner));

CREATE TABLE IF NOT EXISTS public.universities
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    name text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT universities_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.universities
    OWNER to postgres;

ALTER TABLE IF EXISTS public.universities
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.universities TO anon;

GRANT ALL ON TABLE public.universities TO authenticated;

GRANT ALL ON TABLE public.universities TO postgres;

GRANT ALL ON TABLE public.universities TO service_role;
CREATE POLICY u_insert_policy_for_authenticated_user
    ON public.universities
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY u_select_policy_for_authenticated_user
    ON public.universities
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));

CREATE TABLE IF NOT EXISTS public.open_feedback
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    feedback_text text COLLATE pg_catalog."default" NOT NULL,
    open_answer uuid NOT NULL,
    owner uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT open_feedback_pkey PRIMARY KEY (id),
    CONSTRAINT open_feedback_open_answer_fkey FOREIGN KEY (open_answer)
        REFERENCES public.open_answers (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT open_feedback_owner_fkey FOREIGN KEY (owner)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.open_feedback
    OWNER to postgres;

ALTER TABLE IF EXISTS public.open_feedback
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.open_feedback TO anon;

GRANT ALL ON TABLE public.open_feedback TO authenticated;

GRANT ALL ON TABLE public.open_feedback TO postgres;

GRANT ALL ON TABLE public.open_feedback TO service_role;
CREATE POLICY of_insert_policy_for_authenticated_user
    ON public.open_feedback
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY of_select_policy_for_authenticated_user
    ON public.open_feedback
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));

CREATE TABLE IF NOT EXISTS public.profiles
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    first_name text COLLATE pg_catalog."default" NOT NULL,
    last_name text COLLATE pg_catalog."default" NOT NULL,
    university uuid NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_university_fkey FOREIGN KEY (university)
        REFERENCES public.universities (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT profiles_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.profiles
    OWNER to postgres;

ALTER TABLE IF EXISTS public.profiles
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.profiles TO anon;

GRANT ALL ON TABLE public.profiles TO authenticated;

GRANT ALL ON TABLE public.profiles TO postgres;

GRANT ALL ON TABLE public.profiles TO service_role;
CREATE POLICY p_insert_policy_for_authenticated_user
    ON public.profiles
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY p_select_policy_for_owner
    ON public.profiles
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY p_update_policy_for_owner
    ON public.profiles
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = user_id));

CREATE TABLE IF NOT EXISTS public.challenge_pool_user
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    challenge_pool uuid NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT challenge_pool_user_pkey PRIMARY KEY (id),
    CONSTRAINT challenge_pool_user_challenge_pool_fkey FOREIGN KEY (challenge_pool)
        REFERENCES public.challenge_pools (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT challenge_pool_user_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.challenge_pool_user
    OWNER to postgres;

ALTER TABLE IF EXISTS public.challenge_pool_user
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.challenge_pool_user TO anon;

GRANT ALL ON TABLE public.challenge_pool_user TO authenticated;

GRANT ALL ON TABLE public.challenge_pool_user TO postgres;

GRANT ALL ON TABLE public.challenge_pool_user TO service_role;
CREATE POLICY cpu_delete_policy_for_user
    ON public.challenge_pool_user
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY cpu_insert_policy_for_authenticated_user
    ON public.challenge_pool_user
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK (((auth.role() = 'authenticated'::text) AND (auth.uid() = user_id)));
CREATE POLICY cpu_select_policy_for_cp_member
    ON public.challenge_pool_user
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY cpu_select_policy_for_cp_owner
    ON public.challenge_pool_user
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT challenge_pools.owner
   FROM challenge_pools
  WHERE (challenge_pool_user.challenge_pool = challenge_pools.id))));

CREATE OR REPLACE VIEW public.members
 AS
 SELECT challenge_pool_user.id,
    challenge_pool_user.challenge_pool,
    challenge_pool_user.user_id,
    profiles.first_name,
    profiles.last_name
   FROM challenge_pool_user
     LEFT JOIN profiles ON challenge_pool_user.user_id = profiles.user_id;

ALTER TABLE public.members
    OWNER TO postgres;

GRANT ALL ON TABLE public.members TO authenticated;
GRANT ALL ON TABLE public.members TO postgres;
GRANT ALL ON TABLE public.members TO anon;
GRANT ALL ON TABLE public.members TO service_role;

CREATE POLICY cp_delete_policy_for_owner
    ON public.challenge_pools
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = owner));
CREATE POLICY cp_insert_policy_for_authenticated_user
    ON public.challenge_pools
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY cp_select_policy_for_member
    ON public.challenge_pools
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() IN ( SELECT members.user_id
   FROM members
  WHERE (members.challenge_pool = challenge_pools.id))));
CREATE POLICY cp_select_policy_for_owner
    ON public.challenge_pools
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = owner));

CREATE OR REPLACE VIEW public.open_answer_performances
 AS
 SELECT challenge_pool_user.id,
    open_answers.id AS open_answer_id,
    open_answers.answer_text,
    open_answers.version,
    open_answers.created_at,
    open_questions.question_text
   FROM challenge_pool_user
     JOIN open_answers ON open_answers.owner = challenge_pool_user.user_id
     JOIN open_questions ON open_questions.id = open_answers.open_question;

ALTER TABLE public.open_answer_performances
    OWNER TO postgres;

GRANT ALL ON TABLE public.open_answer_performances TO authenticated;
GRANT ALL ON TABLE public.open_answer_performances TO postgres;
GRANT ALL ON TABLE public.open_answer_performances TO anon;
GRANT ALL ON TABLE public.open_answer_performances TO service_role;

CREATE OR REPLACE VIEW public.open_question_performances
 AS
 SELECT challenge_pool_user.id,
    open_questions.id AS open_question_id,
    open_questions.question_text,
    correct_open_answers.answer_text,
    open_questions.created_at
   FROM challenge_pool_user
     JOIN open_questions ON open_questions.owner = challenge_pool_user.user_id
     JOIN correct_open_answers ON correct_open_answers.open_question = open_questions.id;

ALTER TABLE public.open_question_performances
    OWNER TO postgres;

GRANT ALL ON TABLE public.open_question_performances TO authenticated;
GRANT ALL ON TABLE public.open_question_performances TO postgres;
GRANT ALL ON TABLE public.open_question_performances TO anon;
GRANT ALL ON TABLE public.open_question_performances TO service_role;

CREATE OR REPLACE VIEW public.open_feedback_performances
 AS
 SELECT challenge_pool_user.id,
    open_feedback.id AS open_feedback_id,
    open_feedback.feedback_text,
    open_feedback.created_at,
    open_answers.answer_text,
    open_questions.question_text
   FROM challenge_pool_user
     JOIN open_feedback ON open_feedback.owner = challenge_pool_user.user_id
     JOIN open_answers ON open_answers.id = open_feedback.open_answer
     JOIN open_questions ON open_questions.id = open_answers.open_question;

ALTER TABLE public.open_feedback_performances
    OWNER TO postgres;

GRANT ALL ON TABLE public.open_feedback_performances TO authenticated;
GRANT ALL ON TABLE public.open_feedback_performances TO postgres;
GRANT ALL ON TABLE public.open_feedback_performances TO anon;
GRANT ALL ON TABLE public.open_feedback_performances TO service_role;

CREATE OR REPLACE FUNCTION public.fetch_my_challenge_pools(
	user_id_input uuid)
    RETURNS TABLE(id uuid, description text, owner uuid, created_ad timestamp without time zone) 
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  select *
  from challenge_pools
  where owner = user_id_input
  or id in (
    select challenge_pool
    from challenge_pool_user
    where user_id = user_id_input
  );
$BODY$;

ALTER FUNCTION public.fetch_my_challenge_pools(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.fetch_my_challenge_pools(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.fetch_my_challenge_pools(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.fetch_my_challenge_pools(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.fetch_my_challenge_pools(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.fetch_my_challenge_pools(uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.join_challenge_pool(
	invite_code_input text,
	user_id_input uuid)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
  declare
    challenge_pool_id uuid;
    invite_code_valid_until timestamp;
  begin
    select challenge_pool, valid_until
    into challenge_pool_id, invite_code_valid_until
    from invite_codes
    where code = invite_code_input;
    
    if invite_code_valid_until < now() then
      -- TODO: raise an exception
      return 'false';
    end if;

    -- TODO: prevent duplicates in challenge_pool_user ->  raise an exception

    insert into challenge_pool_user(challenge_pool, user_id)
    values (challenge_pool_id, user_id_input);
    return challenge_pool_id::text;
  end;
$BODY$;

ALTER FUNCTION public.join_challenge_pool(text, uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.join_challenge_pool(text, uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.join_challenge_pool(text, uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.join_challenge_pool(text, uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.join_challenge_pool(text, uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.join_challenge_pool(text, uuid) TO service_role;